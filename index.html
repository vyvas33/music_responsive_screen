<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Music Responsive Webscreen (File & Mic Modes)</title>
  <style>
    /* Basic reset */
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      background-color: black;
      font-family: sans-serif;
      color: white;
    }

    /* A translucent control bar at the top */
    #controls {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 10px;
      background: rgba(255, 255, 255, 0.1); /* translucent */
      padding: 10px;
    }

    /* Icon-like buttons */
    button {
      background: none;
      border: none;
      color: white;
      font-size: 16px;
      cursor: pointer;
      padding: 6px 10px;
      border-radius: 4px;
      transition: background 0.2s;
    }
    button:hover {
      background: rgba(255, 255, 255, 0.2);
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Translucent File Input */
    #fileInput {
      font-size: 14px;
      padding: 6px;
      cursor: pointer;
      color: #fff;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 4px;
      transition: background 0.2s;
    }
    #fileInput:hover {
      background: rgba(255, 255, 255, 0.2);
    }
    /* Make the default "Choose File" button match styling (for Chromium-based browsers) */
    #fileInput::-webkit-file-upload-button {
      cursor: pointer;
      background: none;
      border: none;
      color: #fff;
      font-size: 14px;
    }

    /* Range sliders (track position & threshold) */
    input[type="range"] {
      -webkit-appearance: none;
      width: 120px;
      background: transparent;
      cursor: pointer;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      height: 14px;
      width: 14px;
      border-radius: 50%;
      background: white;
      border: 1px solid #888;
      margin-top: -5px;
    }
    input[type="range"]::-webkit-slider-runnable-track {
      height: 4px;
      background: rgba(255,255,255,0.4);
      border-radius: 2px;
    }

    /* Labels */
    label {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      font-size: 12px;
      color: #fff;
    }
    #thresholdInput {
      width: 60px;
      background: rgba(255, 255, 255, 0.1);
      color: #fff;
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 4px;
      padding: 4px;
      margin-top: 4px;
      transition: background 0.2s;
    }
    #thresholdInput:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    /* Translucent Color Picker */
    #colorInput {
      width: 50px;
      height: 30px;
      margin-top: 4px;
      border-radius: 4px;
      border: 1px solid rgba(255, 255, 255, 0.3);
      background: rgba(255, 255, 255, 0.1);
      cursor: pointer;
      transition: background 0.2s;
    }
    #colorInput:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    /* Position slider container so it lines up nicely in the controls */
    #trackSliderContainer {
      display: flex;
      flex-direction: column;
      font-size: 12px;
    }
    #trackSliderLabel {
      margin-bottom: 4px;
    }

    /* Hide these elements when in mic mode */
    .file-only {
      display: none;
    }
  </style>
</head>
<body>

  <div id="controls">
    <!-- Mode Buttons -->
    <button id="fileModeBtn">File Mode</button>
    <button id="micModeBtn">Mic Mode</button>

    <!-- Translucent File Input (File Mode Only) -->
    <input type="file" id="fileInput" accept="audio/*" class="file-only">

    <!-- Buttons (File Mode Only) -->
    <button id="startBtn" class="file-only" disabled>▶︎</button>
    <button id="pauseBtn" class="file-only" disabled>⏸</button>
    <button id="restartBtn" class="file-only" disabled>↺</button>

    <!-- Track Slider (File Mode Only) -->
    <div id="trackSliderContainer" class="file-only">
      <span id="trackSliderLabel">Track</span>
      <input type="range" id="trackSlider" value="0" min="0" step="0.01">
    </div>

    <!-- Threshold & Color (Applies to Both) -->
    <label>
      Threshold
      <input type="number" id="thresholdInput" value="20" min="0" max="255">
    </label>
    <label>
      Flicker Color
      <input type="color" id="colorInput" value="#ff0000">
    </label>
  </div>

  <!-- Hidden audio element (File Mode) -->
  <audio id="audio" crossorigin="anonymous"></audio>

  <script>
    /*====================================
     * Global State & DOM Elements
     *====================================*/
    let audioContext;
    let currentAnalyser = null;  // We'll swap out depending on mode

    // FILE MODE variables
    let fileAnalyser = null;
    let fileSource   = null;
    let fileInitialized = false;

    // MIC MODE variables
    let micAnalyser = null;
    let micStream   = null;
    let micActive   = false;

    // Flicker config
    let threshold    = 20;
    let flickerColor = '#ff0000';

    // DOM elements
    const fileModeBtn    = document.getElementById('fileModeBtn');
    const micModeBtn     = document.getElementById('micModeBtn');
    const fileInput      = document.getElementById('fileInput');
    const audioEl        = document.getElementById('audio');
    const startBtn       = document.getElementById('startBtn');
    const pauseBtn       = document.getElementById('pauseBtn');
    const restartBtn     = document.getElementById('restartBtn');
    const trackSlider    = document.getElementById('trackSlider');
    const thresholdInput = document.getElementById('thresholdInput');
    const colorInput     = document.getElementById('colorInput');

    /*====================================
     * MODE SWITCHING
     *====================================*/
    fileModeBtn.addEventListener('click', () => {
      switchToFileMode();
    });
    micModeBtn.addEventListener('click', () => {
      switchToMicMode();
    });

    function switchToFileMode() {
      micActive = false;
      hideMicUI();
      showFileUI();
      currentAnalyser = fileAnalyser || null;
    }

    async function switchToMicMode() {
      // Pause file if playing
      audioEl.pause();
      // Hide file UI
      hideFileUI();

      // If we haven't started mic mode yet, request access:
      if (!micAnalyser) {
        await enableMicrophone();
      }
      micActive = true;
      showMicUI();
      currentAnalyser = micAnalyser || null;
    }

    function showFileUI() {
      document.querySelectorAll('.file-only').forEach(el => {
        el.style.display = 'inline-flex';
      });
    }

    function hideFileUI() {
      document.querySelectorAll('.file-only').forEach(el => {
        el.style.display = 'none';
      });
    }

    function showMicUI() {
      // Currently, we don't have separate mic-only elements
      // but we might, so you could unhide them here if needed
    }

    function hideMicUI() {
      // If you had separate mic UI, hide it here
    }

    /*====================================
     * FILE MODE SETUP
     *====================================*/
    fileInput.addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (!file) return;
      fileInitialized = true;

      const url = URL.createObjectURL(file);
      audioEl.src = url;

      // Enable file-control buttons
      startBtn.disabled   = false;
      pauseBtn.disabled   = false;
      restartBtn.disabled = false;

      // Set up file-based analyser if not set
      setupFileAnalyser();

      // Update track slider max when metadata loads
      audioEl.addEventListener('loadedmetadata', () => {
        trackSlider.max = audioEl.duration.toFixed(2);
      });
    });

    function setupFileAnalyser() {
      // Create or reuse the AudioContext
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
      }
      if (!fileAnalyser) {
        fileAnalyser = audioContext.createAnalyser();
        fileAnalyser.fftSize = 256;
      }
      if (!fileSource) {
        fileSource = audioContext.createMediaElementSource(audioEl);
        fileSource.connect(fileAnalyser);
        fileAnalyser.connect(audioContext.destination);
      }
      // Use the file analyser if we're in file mode
      if (!micActive) {
        currentAnalyser = fileAnalyser;
      }
    }

    // File-mode buttons
    startBtn.addEventListener('click', () => {
      if (!fileInitialized) return;
      if (audioContext.state === 'suspended') {
        audioContext.resume();
      }
      audioEl.play();
    });

    pauseBtn.addEventListener('click', () => {
      if (!fileInitialized) return;
      audioEl.pause();
    });

    restartBtn.addEventListener('click', () => {
      if (!fileInitialized) return;
      audioEl.currentTime = 0;
      if (audioContext.state === 'suspended') {
        audioContext.resume();
      }
      audioEl.play();
    });

    // Track slider scrubbing
    audioEl.addEventListener('timeupdate', () => {
      trackSlider.value = audioEl.currentTime;
    });
    trackSlider.addEventListener('input', () => {
      if (!fileInitialized) return;
      audioEl.currentTime = parseFloat(trackSlider.value);
    });


    /*====================================
     * MIC MODE SETUP
     *====================================*/
    async function enableMicrophone() {
      try {
        if (!audioContext) {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        // Request access
        micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        micAnalyser = audioContext.createAnalyser();
        micAnalyser.fftSize = 256;

        const source = audioContext.createMediaStreamSource(micStream);
        source.connect(micAnalyser);

      } catch (err) {
        console.error('Microphone access denied or not available.', err);
      }
    }

    /*====================================
     * THRESHOLD & COLOR
     *====================================*/
    thresholdInput.addEventListener('input', () => {
      threshold = parseInt(thresholdInput.value, 10) || 0;
    });
    colorInput.addEventListener('input', () => {
      flickerColor = colorInput.value;
    });

    /*====================================
     * ANIMATION LOOP
     *====================================*/
    function animate() {
      requestAnimationFrame(animate);
      if (!currentAnalyser) return; // No active analyser? Do nothing.

      const bufferLength = currentAnalyser.frequencyBinCount;
      const dataArray = new Uint8Array(bufferLength);
      currentAnalyser.getByteTimeDomainData(dataArray);

      let sum = 0;
      for (let i = 0; i < bufferLength; i++) {
        const val = dataArray[i] - 128; // shift from 0..255 to -128..127
        sum += val * val;
      }
      const rms = Math.sqrt(sum / bufferLength);

      // Flicker if above threshold
      document.body.style.backgroundColor = (rms > threshold) ? flickerColor : 'black';
    }

    // Start the animation loop once
    animate();

    /*====================================
     * DEFAULT MODE
     *====================================*/
    // We'll start in File Mode by default
    switchToFileMode();
  </script>
</body>
</html>
